#include "byos.h"
// Find out what other #include's you need! (E.g., see man pages.)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

// use octal code

// if(strcmp(c -> type, "FORK") == 0). okay?
// hint for recursion and redirection

//list flag

void handler(int sig) {
    int e = 128;
    e += sig;
    exit(e);
}

int flag = 0;


int interp(const struct cmd *c)
{

    int n;
    //NO REDIRECTION
    if((c -> redir_stdout) == NULL) {
        //ECHO
        if (c->type == 0) {
            //print
            printf("%s", c->data.echo.arg);
        }
        //FORX
        if (c->type == 1) {

            //path name
            char *path;
            path = c -> data.forx.pathname;
            char **argv;
            argv = c -> data.forx.argv;
            //in a format ready for straight passing to a suitable exec syscall (which is not execlp)
                // use execv??

            //fork
            pid_t pid = fork();
            if (pid == -1) {
                perror("The following error occur\n");
                return -1;
            } else if (pid == 0) {
                //this is a child
                //signal
                struct sigaction act;
                act.sa_handler = handler;
                act.sa_flags = 0;
                sigemptyset(&act.sa_mask);
                sigaction(SIGINT,&act,NULL);
                //only name
                if (strchr(path, '/') == NULL) {
                    if (execvp(path, argv) < 0) { // The smallest i such that argv[i]==NULL marks the end. how????
                        printf("Error - Execute the command\n");
                        exit(127);
                    }

                }
                //full path
                else {
                    if (execv(path, argv) < 0) {  // The smallest i such that argv[i]==NULL marks the end. how????
                        printf("Error - Execute the command\n");
                        exit(127);
                    }
                }
                exit(0);
            } else {
                //this is a parents
                // waiting for child to terminate
                wait(NULL);
            }

            // choose one that can search PATH so that the pathname can be simply "ls" for example
                // how can i do it?
        }
        //LIST
        if (c->type == 2) {

            n = c -> data.list.n;
            struct cmd *cmds;
            cmds = c -> data.list.cmds;
            flag = 1;
            for(int i = 0; i < n; i++) {
                //each cmd
                struct cmd *each;
                each = &(cmds[i]);
                //printf("%s\n", each -> data.echo.arg);
                //printf("flag - %d\n", flag);
                //recursion with
                interp(each);
            }
            flag = 0;


        }
    }
    // REDIRECTION
    else {
        char *red;
        red = c -> redir_stdout;
        //printf("red = %s\n", red);
        //ECHO
        if (c->type == 0) {
            //in ECHO file redirection == write to the file
            int fd;
            //printf("pass\n");
            //problem 1
            if(flag == 1) {  // 반복 되는 거. 파일이 없으면 만들고 있으면 원래있던 내용 뒤에 내용 추가
                //printf("red = %s\n", red);
                //printf("pass 2 \n");




                if((fd = open(red, O_WRONLY | O_CREAT | O_APPEND, 0666)) >= 0) {  // if file exits or not exits, but no error
                    char *stw;

                    stw = c -> data.echo.arg;
                    //printf("stw = %s\n", stw);
                    //printf("stw = %s\n", stw);
                    write(fd, stw, strlen(stw));

                    close(fd);


                } else {
                    printf("error\n");
                    exit(1);    // return 1 and end the program;
                }
            } else {  // 파일이 없으면 만들고 있으면 지우고 새로
                //printf("pass 1 \n");
                if((fd = open(red, O_WRONLY | O_CREAT | O_TRUNC, 0666)) >= 0) {  // if file exits or not exits, but no error
                    //printf("%s\n", c -> data.echo.arg);
                    char *stw;
                    stw = c -> data.echo.arg;
                    //printf("stw = %s\n", stw);
                    write(fd, stw, strlen(stw));
                    close(fd);
                } else {
                    printf("error\n");
                    exit(1);    // return 1 and end the program;
                }

            }


        }
        //FORX
        if (c->type == 1) {             // STDOUT -> SPECIFIC FILE

            //signal
            struct sigaction act;
            act.sa_handler = handler;
            act.sa_flags = 0;
            sigemptyset(&act.sa_mask);
            sigaction(SIGINT,&act,NULL);
            //path name
            char *path;
            path = c -> data.forx.pathname;
            char **argv;
            argv = c -> data.forx.argv;
            //in a format ready for straight passing to a suitable exec syscall (which is not execlp)
            // use execv??

            //fork
            pid_t pid = fork();
            if (pid == -1) {
                perror("The following error occur\n");
                return -1;
            } else if (pid == 0) {
                //this is a child
                //STDOUT REDIRECTION
                int fd = open(red, O_WRONLY, 0666);
                dup2(fd, 1);
                //signal
                struct sigaction act;
                act.sa_handler = handler;
                act.sa_flags = 0;
                sigemptyset(&act.sa_mask);
                sigaction(SIGINT,&act,NULL);
                //only name
                if (strchr(path, '/') == NULL) {
                    if (execvp(path, argv) < 0) { // The smallest i such that argv[i]==NULL marks the end. how????
                        printf("Error - Execute the command\n");
                        printf("1\n");
                        exit(127);
                    }

                }
                    //full path
                else {
                    if (execv(path, argv) < 0) {  // The smallest i such that argv[i]==NULL marks the end. how????
                        printf("Error - Execute the command\n");
                        printf("2\n");
                        exit(127);
                    }
                }
                exit(0);
                close(fd);
            } else {
                //this is a parents
                // waiting for child to terminate
                wait(NULL);
            }
            dup2(1, 1);
        }
        //LIST
        if (c->type == 2) {
            int n;
            n = c -> data.list.n;
            struct cmd *cmds;
            cmds = c -> data.list.cmds;
            flag = 1;
            for(int i = 0; i < n; i++) {

                //each cmd
//                printf("i = %d\n", i );


                //printf("%s\n", cmds[i].data.echo.arg);
                //printf("%s\n", cmds[i].redir_stdout);

                //recursion with
                interp(&(cmds[i]));     //recursion 쓴건가?
            }
            flag = 0;


        }
    }

    return 0;
}
