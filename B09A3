#include "byos.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>




int interp(const struct cmd *c) {
    int std_dir;
    
    // if there is redirection : change the stdout
    if (c -> redir_stdout != NULL) {
        int new_dir = open(c -> redir_stdout, O_WRONLY|O_CREAT, 0666);
        if(new_dir == -1) {
            return 1;
        }
        std_dir = dup(STDOUT_FILENO);
        dup2(new_dir, STDOUT_FILENO);
        close(new_dir);
    }

    //echo
    if(c -> type == 0) {
        write(STDOUT_FILENO, c -> data.echo.arg, strlen(c -> data.echo.arg));

    }

    //forx
    if(c -> type == 1) {
        char *path;
        path = c -> data.forx.pathname;
        char **argv;
        argv = c -> data.forx.argv;

        int status;
        pid_t pid = fork();
        if (pid == -1) {
            perror("The following error occur\n");
            return -1;
        } else if (pid == 0) {
            //child
            if(strchr(path, '/') == NULL || strstr(path, "./") != NULL) {
                //printf("path - %s\n", path);
                if(execv(path, argv) < 0) {
                    perror("Error");
                    return 0;
                }
            } else {
                if (execvp(path, argv) < 0) { // The smallest i such that argv[i]==NULL marks the end. how????
                    //printf("path = %s\n", path);
                    perror("Error");
                    return 127;

            }
        }
            
            //exit(0);

        } else {
            //parents
            wait(&status);
            if(WIFEXITED(status)) {
                //If the child exits, the return value is the childâ€™s exit status.
                return WEXITSTATUS(status);
            }
            else if (WIFSIGNALED(status)) {
                //If the child is killed by signal, the return value is 128+signal
                return 128 + WTERMSIG(status);
            }
        }

    }

    //list
    if(c -> type == 2){
        int n = c -> data.list.n;
        struct cmd *cmds = c -> data.list.cmds;


        for(int i = 0; i < n; i++) {
            printf("type = %d\n", cmds[i].type);
            int ret = interp(&(cmds[i]));
            if(ret == 128 + SIGINT) {
                
                return (128 + SIGINT);
            }
        }
    }

    //restore std_out
    if (c -> redir_stdout != NULL) {
        dup2(std_dir, 1);
        close(std_dir);
    }
    
    return 0;

}

